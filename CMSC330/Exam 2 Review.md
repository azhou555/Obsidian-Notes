# Context Free Grammar
A CFG can describe any regex. Not all CFGs can be described by regexes, however. 
S -> Ss | s
Equivalent to `s+` in regex. In this case, we would describe `S` as being non-terminal. That is, it can be further evaluated. On the other hand, `s` is just a member of the alphabet of the grammar and is terminal. It can *NO* longer be evaluated. 
Generally, we evaluate CFG's in a left-most fashion. That is, when we are attempting to derive a pattern using a CFG, we will choose a parse path that fits the left most symbols first. 
We can describe a CFG as being **ambiguous** if we can left derive the same expression in two different ways. 
S -> NSP | s
N -> Nn | n
P -> pPp | Îµ
If we have a string such as `nns`, we could have:
1. S -> NSP -> NnSP -> nnSP -> nnsP -> nns 
2. S -> NSP -> nSP -> nNSPP -> nnSPP -> nnsPP -> nnsP -> nns

Parse trees are not the same as Abstract Syntax Trees. If we take the expression 
a + b, 
a parse tree looks like
```
			+
		 /     \
	    a       b  
```
The corresponding AST is Plus(a, b). 
AST shows how the expression will be evaluated, whereas a parse tree represents the structure of the expression. 
# LPE
## Lexing
Lexing is the initial stage. What happens during this stage is that a lexer converts characters into **tokens** that the parser can later evaluate. However, it can only convert things that are part of the alphabet of the CFG into tokens. If the lexer encounters any characters, symbols, etc. that are not included in the alphabet of the grammar, it will cause an error.  Be especially careful on this part. You can't assume that parentheses are part of the grammar. Even if 1, 2, 3, & 4 are part of the grammar, that *DOESN'T* mean that 5 is also a part of the grammar. 
Given a grammar such as
E -> M and E | M or E | M
M -> N + M | N - M | N
N -> 1 | 2 | 3 | 4 | true | false | (E)
The expression true - false will lex properly, even if it isn't actually a valid statement in OCaml. However, the expression 5 - 3 will not pass the lexer, even if we view it as a valid statement. Any characters other than 1, 2, 3, 4, false, true, (, or ) will result in an error in the lexer. An expression with an invalid structure such as ( 3 - false true will not result in an error in the lexer. Instead, it will move ahead to 
## Parsing
The parse takes the tokens generated by the lexer and attempts to structure it into an AST that makes sense in the CFG. Think back to project 4. Consume tokens, create a structure. Refer back to parse tree. If we have the expression 3 + 4, after it is lexed into something like [TokInt(3), TokPlus, TokInt(4)] or something along those lines, the parser will read it and create something akin to Plus(3, 4). If we take the expression ( 3 - false true, although it will pass the lexer since it consists solely of characters in the alphabet of our corresponding grammar, it will not pass the parser because it is a statement that is not structured correctly. For example, a hanging left paren and a dangling true. Note that it wouldn't actually count 3 - false as an error, because it fits the desired structure for subtraction. 

## Evaluating/Interpreting
Finally, the expression is interpreted. If it passes the parser and lexer, now it just checks whether or not the statement really is valid. This will usually just be type checking. 3 - false fits the alphabet(passes lexer)  and has the correct structure for subtraction(passes parser), but it can't be properly evaluated because you can't subtract false from 3. 
# Operational Semantics
Grants meaning to a language and proves correctness of a program. 
Explains how an expression evaluates a certain value. 
What an expression means. 
Environment: maps a symbol to a value. 
Axioms are facts: an integer n evaluates to itself. An integer n has type int. Etc. 
Be really particular about the syntax. Just follow the exact format provided. 

## Type checking
# Subtyping
# Lambda Calculus
Is Turing complete. That means that anything and everything can be represented in lambda calculus. 
CFG:
E -> x | LxE | E E | (E)
Anything that can be derived with the above grammar then it is valid. 
## Beta Reduction
Expression of form (Lx.e1) e2. Evaluates e1 substituting every instance of x in e1 with e2/evaluation of e2(lazy vs. eager). 
We call an expression the **Beta Normal Form** or **BNF** is the expression has been beta reduced as much as possible: no more reductions are possible. 
Note that in an expression such as 
(Lx. y), 
we can't just reduce this to y since anything that is passed in will return y anyways(won't be substituted). Since this expression is essentially a function that returns y regardless, we can't just reduce it to y or it will change the structure of a expressions that it is contained within. 
## Lazy vs Eager evaluation
2 ways to evaluate an expression. 
### Lazy
Call by name. Input the entire parameter expression directly into the function application. 
### Eager
Call by value. Evaluate e2 first before substituting into e1. 

Evaluating a lambda expression with either method results in the same beta-normal expression. However, one step into the reduction might yield different results. 
## Scoping Rules/Left Associativity
`a b c` -> `(a b) c`
Scope of a parameter goes until the first unmatched right parentheses or end of the line
(Lx. Ly. a x (Lx.xx) x) x
First x is bound to the the second and second to last x, x3 is bound to x4 and x5, and x6 is free. Note that if x3, x4, and x5 were changed to y, for example, the expression would remain the same. Similarly, if x1, x2, and x5 were changed to something else, the expression remains the same as well. 
## Encoding
Lambda expressions can express values like 1, 2, 3 etc., true, false, blah blah blah. Replace stuff with the corresponding lambda expressions to create the desired expression. 
## Free vs Bound Variables
If a var is in scope of it being defined, it is bound. Otherwise, it is free. 
(Lx.xyz) 
x is being bound, whereas y and z are free. 

